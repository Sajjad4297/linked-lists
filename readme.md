

# درسنامه لیست‌های پیوندی (Linked Lists)

---

## 1. لیست پیوندی چیست؟

<p dir="rtl">
لیست پیوندی یک <b>ساختار داده‌ای خطی</b> است که از مجموعه‌ای از <b>'گره'ها (Node)</b> ساخته شده است.
هر 'گره' شامل دو بخش است:
</p>
در لیست پیوندی شما میتواند هر آیتم را در هر کجای حافظه قرار دهید، اما باید جایگاه آیتم بعدی را هم در کنار آن آیتم قرار بدهید، در واقع لیست پیوندی مجموعه ای از داده ها است که به صورت پراکنده در حافظه ذخیره شده اند اما هر کدام به وسیله داشتن آدرس بعدی در حافظه به آن متصل شده است.
</br>
</br>

هر "node" یا "گره" در یک لیست پیوندی به دو قسمت نیاز دارد:
</br>

- <b>دیتا (Data)</b>: داده‌ای که 'گره' نگه می‌دارد.
- <b>اشاره‌گر (Pointer/Next)</b>: آدرس 'گره' بعدی در لیست.

```
      +-----------+-------------+
      |   DATA    |   POINTER   |
      |  (مقدار)  | (آدرس بعدی) |
      +-----------+-------------+
            \           /
             \_________/
                  |
              یک گره (Node)
```
به زبان ساده: به جای اینکه مثل آرایه، همه‌ی عناصر کنار هم در حافظه باشند هر 'گره' خودش می‌داند 'گره' بعدی کجاست.

---
##  ساختار یک 'گره' و لیست پیوندی

### ساختار node یا گره
```text
Data | Next
```
برای ساخت یک گره حداقل نیاز به یک داده برای ذخیره و یک pointer برای اشاره به گره بعدی نیاز داریم.
### مثال

```
Memory Addresses:            1001         1020          1190
Nodes:                     [10|1020] -> [20|1190] -> [30|Next] -> None
```

-  شروع لیست از <b>"Head"</b> است که به اولین گره لیست اشاره می‌کند.
-   به آخرین گره لیست که اشاره‌گرش `null` است <b>"Tail"</b> یا "دم" هم می‌گویند.

### شکل شماتیک
```
Head                          Tail
  |                             |
  v                             v
[10|Next] -> [20|Next] -> [30|Next] -> Null
```


---
##  عملیات روی لیست پیوندی

### عملیات درج

تصور کنید که می‌خواهیم یک گره B (گره جدید) را بین گره A (گره چپ) و گره C (گره راست) درج کنیم.
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]



                            [Data|Next]

                                ^
                                |
                            B(New node)
```
در این صورت B باید به C به عنوان next اشاره کند:

`B(New node).next -−> C(Right node);`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]

                                                     ^
                                                     |
                         [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
اینک گره سمت راست (A) باید به گره جدید (B) اشاره کند:

`A(Left node).next -−> B(New node);`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(B)]                               [Data|Next]
            |
            |                                         ^
            |                                         |
            \-----------> [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
بدین ترتیب گره جدید در میان دو گره قبلی قرار می‌گیرد. لیست جدید به صورت زیر خواهد بود:
```
     A(Left node)                                    C(Right node)
          |                                                |
          v                                                v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]

                                   ^
                                   |
                               B(New node)
```
اگر بخواهیم گرهی را در ابتدای لیست اضافه کنیم نیز مراحل مشابهی را طی می‌کنیم، فقط در یک سمت بجای گره head را داریم.

 زمانی که می‌خواهیم گرهی را در انتهای لیست درج کنیم، گره جدید به یک مقدار null اشاره می‌کند.
</br>
</br>
### عملیات حذف
ابتدا گره هدف که می‌خواهیم حذف کنیم را با استفاده از الگوریتم‌های جستجو می‌یابیم.

فرض کنید اینبار میخواهیم گره B را از میان A و C حذف کنیم:
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]
```
گره چپ (A) باید به گره راست هدف (C) اشاره کند:

`A(Left node).next −> C(Target node.next);`
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(C)]          [Data|Next(C)]---------> [Data|Next]
             |                                            ^
             |                                            |
             \____________________________________________/
```
با این کار پیوندی که از گره راست (A) به گره هدف(B) وجود داشت از بین می‌رود. حالا اشاره‌گر گره هدف (B) را حذف میکنیم تا ارتباطش با گره راست (C) هم قطع شود:

`B(Target node).next −> NULL;`
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(C)]          [Data|Next(C)]           [Data|Next]
             |                                            ^
             |                                            |
             \____________________________________________/
```
 ما می‌توانیم گره حذف شده (B) را در حافظه نگه داریم ولی حالا که نیازی به آن نداریم می‌توانیم به سادگی آن را به طور کامل پاک کنیم و حافظه اشغال شده را آزاد کنیم:

`Delete(node B);`
```
     A(Left node)            C(Right node)
          |                         |
          v                         v
    [Data|Next(C)] ----------> [Data|Next]
```


---


##  انواع لیست‌های پیوندی
چند مدل لیست پیوندی داریم که اینجا می‌بینیم:
### لیست پیوندی یک‌طرفه (Singly Linked List)

```
Head
  |
  v
[10|Next] -> [20|Next] -> [30|Next] -> None
```
همانی که بالا هم توضیح دادیم، نوع عادی و اولیه لیست پیوندی حداقل به دو قسمت داده و اشاره‌گر نیاز داره.

لیست پیوندی یک‌‌طرفه در پیاده‌سازی صف‌ها، پشته‌ها و برخی از الگوریتم‌ های مرتب‌سازی کاربرد داره.

---

### لیست پیوندی دوطرفه (Doubly Linked List)

```
None <- [Prev|10|Next] <-> [Prev|20|Next] <-> [Prev|30|Next] -> None
```
گره های این مدل لیست پیوندی می‌تونن هم به عنصر بعدی‌شان اشاره کنن و هم به قبلی!

در واقع با استفاده از یک اشاره‌گر دیگر (Prev) می‌تونن به عضو قبلی هم اشاره کنن، پس میشه به عقب هم پیمایش کرد ولی برای ذخیره اشاره‌گر اضافی به حافظه بیشتری نیاز هست.

این لیست انعطاف‌پذیری بیشتری داره و
عملیات درج و حذف عناصر در وسط لیست به خاطر وجود اشاره‌گر به گره قبلی، سریع‌تر انجام می‌شه.بیشترین کاربردش هم در پیاده‌سازی گراف‌ها است.


---

### لیست پیوندی حلقوی (Circular Linked List)

```
        +----------------+
        |                |
[10|Next] -> [20|Next] -> [30|Next]
        ^                |
        +----------------+
```
این لیست پیوندی ساختار دایره‌ای داره. در واقع، اشاره‌گر  آخرین گره به گره اول اشاره می‌کنه و یک ساختار دایره‌ای رو تشکیل می‌ده؛ همچنین پیمایش مداومی هم داره که می‌شه از هر گره‌ای شروع کرد و به همان گره بازگشت. کاربرد آن نیز در پیاده‌سازی صف‌های حلقوی و مدیریت حافظه است.



---


##  مزایا و معایب

### مزایای لیست های پیوندی یک‌طرفه
به عنوان مزیت، می‌توانیم به سه نکته برجسته درباره این نوع از لیست‌های پیوندی اشاره کنیم:

- **«آزادی سازی حافظه پویا (Dynamic Memory Allocation | DMA):**  به این معنا که اندازه لیست در زمان اجرای برنامه با حذف شدن یا اضافه شدن داده‌های لیست به‌ صورت پویا کم یا زیاد می‌شود.

- **«مناسب برای کار با کش» (Cache Friendliness):** از آنجا که گره‌ها را می‌توان در صف‌های جداگانه‌ای در کش‌ ذخیره کرد، لیست‌های پیوندی یک‌طرفه برای کار با حافظه کش گزینه مناسبی هستند. این کار احتمال از دست رفتن داده‌ها در کش را کاهش داده و کارایی سیستم را افزایش می‌دهد.

- **«کارآمدی در فضای حافظه» (Space-Efficient):** لیست‌های پیوندی یک‌طرفه در استفاده از فضای ذخیره‌سازی بسیار کارآمد هستند. زیرا این لیست‌ها به‌جای اینکه فضای پیوسته و بزرگی از حافظه را اشغال کنند، برای هر عنصر فقط به ذخیره آدرس گره بعدی نیاز دارند.

### معایب لیست های پیوندی یک‌طرفه
- **کارایی ضعیف در دسترسی تصادفی**: برای دسترسی به هر مقداری در لیست‌های پیوندی یک‌طرفه باید از سمت سر لیست تا رسیدن به گره حاوی مقدار مورد نظر پیمایش کنیم. این نوع از دسترسی، لیست پیوندی یک‌طرفه را برای اجرای عملیات دسترسی تصادفی نسبت به آرایه‌ها بسیار ضعیف‌تر می‌کند.

- **افزایش سربار حافظه**: لیست‌های پیوندی یک‌طرفه نیاز به حافظه اضافی برای ذخیره آدرس گره بعدی یا نشانگر در هر گره دارند. این کار باعث می‌شود که در مقایسه با آرایه‌ های برنامه نویسی هزینه بیشتری را بر روی حافظه سیستم وارد کنند.

- **آسیب‌پذیر بودن در مقابل از دست رفتن داده‌ها**: در لیست‌های پیوندی یک‌طرفه،
اگر اشاره‌گر گره‌‌ای حذف یا خراب شود دیگر امکان پیمایش بر بروی لیست و دسترسی به گره‌های بعدی وجود ندارد. در نتیجه لیست‌های پیوندی در مقابل از دست‌دادن داده‌ها می‌توانند بسیار آسیب‌پذیر باشند.

- **نامناسب برای پردازش‌های موازی**: لیست‌های پیوندی یک‌طرفه برای پردازش‌های موازی مناسب نیستند. زیرا به‌روزرسانی مقادیر گره‌ها نیازمند دسترسی انحصاری به اشاره‌گر گره بعدی دارد و دسترسی انحصاری چیزی نیست که به‌سادگی در محیط‌های عملیاتی موازی بدست آید.

- **پیمایش روبه‌عقب ممکن نیست**: لیست‌های پیوندی یک‌طرفه، از عملیات پیمایش لیست به سمت عقب پشتیبانی نمی‌کنند. در واقع گره‌ها اصلا نمی‌دانند که گره قبلی در کجای حافظه قرار دارد.

---


##  تفاوت های لیست پیوندی با آرایه
</br>
خب اولین چیزی که باید بررسی کنیم اینه که این لیست ها کجا به درد میخورن و چه وقت و چرا باید بجای آرایه از لیست های پیوندی استفاده کنیم.
</br>

### ساختار، اندازه و میزان حافظه اشغالی
در حالی که آرایه ها به صورت پشت سر هم در حافظه ذخیره میشن، لیست های پیوندی نیازی ندارن که پی در پی باشن و هرکدوم میتونن هرجایی باشن.
```
        آرایه:
        [ 10 ][ 20 ][ 30 ]


        لیست پیوندی:
        [ 10 ] -----------------------> [ 20 ]
                                          |
                    [ 30 ] <--------------/
                    |
                    \---------> NULL
```
برای اینکه هر node در لیست بتونه اون یکی رو هر کجا که باشه پیدا کنه، نیاز به آدرس node بعدی داره:
```
    HEAD
        |
        v
    +------+-----+      +------+-----+      +------+-----+
    |  10  |  *------>  |  20  |  *------>  |  30  | NULL|
    +------+-----+      +------+-----+      +------+-----+
        (گره اول)             (گره دوم)             (گره آخر)
```
در نتیجه لیست پیوندی بخاطر اینکه یک آدرس یا pointer هم باید ذخیره کنه به حافظه بیشتری هم نسبت به آرایه نیاز داره.

آرایه ها اندازه ثابتی دارن و این اندازه باید در هنگام تعریف آرایه مشخص بشه. شاید فکر کنید بعضی زبان های برنامه نویسی مثل python و javascript میتونن اندازه متغیری داشته باشن، ولی در واقع آرایه در اونها هم اندازه ثابتی داره! وقتی شما یه داده دیگه رو به آرایه اضافه می کنید، آرایه قبلی پاک میشه و همه داده ها به یک آرایه جدید (و بزرگ تر) اضافه میشن.
در حالی که یک لیست پیوندی میتونه اندازه کاملا متغیری داشته باشه و تغییر کنه.
### سرعت پیدا کردن اطلاعات

فرض کنید ما میخواهیم آیتم 100 ام از یک آرایه را بخوانیم، کار بسیار راحتی خواهد بود کافی است از آدرس آیتم اول، 'گره' و نه خانه به جلو برویم. پس عملا ما با یک عملیات آیتم صدم را پیدا میکنیم، بنابراین پیچیدگی زمانی آن، O(1) خواهد بود.
اما درباره لیست پیوندی، قضیه متفاوت خواهد بود، برای پیدا کردن آیتم صدم در لیست پیوندی ابتدا باید آیتم یک را پیدا کنیم سپس آدرس آیتم دوم را در آنجا پیدا کنیم، بعد آیتم سوم و چهارم و… همین روند را ادامه بدهیم تا بالاخره به آیتم صدم برسیم. به عبارتی باید خانه ها را یکی یکی به جلو بیاییم پس پیچیدگی زمانی پیدا کردن آیتم در لیست پیوندی به صورت O(n) خواهد بود.
</br>
</br>
### سرعت اضافه یا حذف کردن دیتا

به نظر میرسد اضافه کردن دیتا به آرایه کار راحتی است، کافیست بعد از آخرین آیتم، یک آیتم جدید قرار دهیم. اما مسئله، زمانی پیچیده میشود که بخواهیم به اول یا اواسط یک آرایه آیتم جدید اضافه کنیم، در این صورت لازم داریم که تمام آیتم های بعدی را به یک خانه جلوتر منتقل کنیم. برای مثال اگر ما یک آرایه داشته باشیم که در حال حاضر ده عضو داشته باشد و بخواهیم به اول آن یک آیتم جدید اضافه کنیم باید آیتم یک را ببریم بجای آیتم دو و آیتم دو بجای آیتم سه ببریم و همین روند را ادامه دهیم تا همه آیتم ها یک خانه جابجا شوند و بتوانیم آیتم جدید را در خانه اول بگذاریم. اضافه کردن به میانه آرایه هم فرایند مشابهی دارد.

همین روند برای حذف کردن دیتا هم وجود دارد. باید تمام آیتم های بعد از آیتم حذف شده، یک خانه به عقب برگردند. برای حذف و اضافه کردن در آرایه، ممکن است نیاز پیدا کنیم تا همه آیتم ها را جابجا کنیم، پس میتوانیم بگوییم که پیچیدگی زمانی این فرایند به صورت O(n) خواهد بود.

اما درباره لیست پیوندی چطور؟ اضافه کردن در لیست پیوندی بسیار ساده است، آیتم جدید را در هر جایی از حافظه که بخواهیم قرار میدهیم و آدرس آن را در آیتم قبلی قرار میدهیم. فرض کنیم که یه لیست پیوندی با 10 آیتم داریم و میخواهیم آیتم جدیدی بین آیتم 3 و 4 اضافه کنیم. کافیست آیتم جدید را در جایی از حافظه قرار دهیم و آدرس آن را به آیتم 3 بدهیم و آدرس آیتم 4 را به آیتم جدید بدهیم. بدون اینکه نیاز به جابجایی دیتا های قبلی وجود داشته باشد.

حذف کردن از لیست پیوندی نیز کار راحتی خواهد بود، کافییست آیتم مورد نظر را از حافظه حذف کنیم و آدرس آیتم بعدی را به آیتم قبلی بدهیم. اضافه و حذف کردن در لیست پیوندی با یک عملیات انجام خواهد شد پس پیچیدگی زمانی آن به صورت O(1) خواهد بود.
</br>
</br>
</br>

<table>
<tr>
<th>ویژگی</th>
<th>آرایه</th>
<th>لیست پیوندی</th>
</tr>
</tr>
<tr>
<td>حافظه</td>
<td>کمتر</td>
<td>بیشتر (برای اشاره‌گرها)</td>
</tr>
<tr>
<td>اندازه</td>
<td>ثابت</td>
<td>پویا</td>
</tr>
<tr>
<td>دسترسی به عناصر</td>
<td>خیلی سریع O(1)</td>
<td>زمان برO(n)</td>
<tr>
<td>درج/حذف</td>
<td>زمان‌بر O(n)</td>
<td>خیلی سریع O(1)</td>
</tr>
</table>



### نتیجه

اینکه سراغ کدام یک برویم بستگی به نیاز ما دارد. اگر قرار است که مجموعه ای داشته باشیم که مدام به آن اضافه یا از آن حذف کنیم، بهتر است از لیست پیوندی استفاده کنیم. برای مثال اگر بخواهیم یک نرم افزار todo list بنویسیم که کار هایمان را در آن قرار دهیم بهتر است از لیست پیوندی استفاده کنیم چون مدام نیاز داریم میان کارهای قبلی، کار جدیدی اضافه کنیم و کار هایی که انجام میدهیم را از لیست حذف کنیم.

اما اگر مجموعه داده های ما تغییرات زیادی ندارد و ما نیاز داریم که مدام از میانه آن آیتم های مان را بخوانیم بهتر است از آرایه کمک بگیریم، برای مثال اگر بخواهیم یک نرم افزار دیکشنری بنویسیم بهتر است از آرایه برای نگهداری لغات استفاده کنیم به دلیل اینکه لغات دیکشنری معمولا کم و زیاد نمیشود اما در عوض همیشه نیاز داریم که کلمه مورد نظرمان را بین کلمات پیدا کنیم.


---
