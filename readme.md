

# درسنامه لیست‌های پیوندی (Linked Lists)
## فهرست
- [لیست پیوندی چیست؟](#لیست-پیوندی-چیست)
- [ساختار یک 'گره' و لیست پیوندی](#ساختار-یک-گره-و-لیست-پیوندی)
- [عملیات روی لیست پیوندی](#عملیات-روی-لیست-پیوندی)
- [انواع لیست‌های پیوندی](#انواع-لیستهای-پیوندی)
- [مزایا و معایب](#مزایا-و-معایب)
- [مثال‌هایی از کاربرد لیست‌های پیوندی در زندگی واقعی](#مثالهایی-از-کاربرد-لیستهای-پیوندی-در-زندگی-واقعی)
- [تفاوت های لیست پیوندی با آرایه](#تفاوت-های-لیست-پیوندی-با-آرایه)


##  لیست پیوندی چیست؟

لیست پیوندی یک <b>ساختار داده‌ای خطی</b> است که از مجموعه‌ای از <b>'گره'ها (Node)</b> ساخته شده است.
هر 'گره' شامل دو بخش است:
</p>
در لیست پیوندی شما میتواند هر آیتم را در هر کجای حافظه قرار دهید، اما باید جایگاه آیتم بعدی را هم در کنار آن آیتم قرار بدهید، در واقع لیست پیوندی مجموعه ای از داده ها است که به صورت پراکنده در حافظه ذخیره شده اند اما هر کدام به وسیله داشتن آدرس بعدی در حافظه به آن متصل شده است.
</br>
</br>

هر "node" یا "گره" در یک لیست پیوندی به دو قسمت نیاز دارد:
</br>

- <b>دیتا (Data)</b>: داده‌ای که 'گره' نگه می‌دارد.
- <b>اشاره‌گر (Pointer/Next)</b>: آدرس 'گره' بعدی در لیست.

```
      +-----------+-------------+
      |   DATA    |   POINTER   |
      |  (مقدار)  | (آدرس بعدی) |
      +-----------+-------------+
            \           /
             \_________/
                  |
              یک گره (Node)
```
به زبان ساده: به جای اینکه مثل آرایه، همه‌ی عناصر کنار هم در حافظه باشند هر 'گره' خودش می‌داند 'گره' بعدی کجاست.

---
##  ساختار یک 'گره' و لیست پیوندی

### ساختار node یا گره
```text
Data | Next
```
برای ساخت یک گره حداقل نیاز به یک داده برای ذخیره و یک pointer برای اشاره به گره بعدی نیاز داریم.
### مثال

```
Memory Addresses:            1001         1020          1190
Nodes:                     [10|1020] -> [20|1190] -> [30|Next] -> None
```

-  شروع لیست از <b>"Head"</b> است که به اولین گره لیست اشاره می‌کند.
-   به آخرین گره لیست که اشاره‌گرش `null` است <b>"Tail"</b> یا "دم" هم می‌گویند.

### شکل شماتیک
```
Head                          Tail
  |                             |
  v                             v
[10|Next] -> [20|Next] -> [30|Next] -> Null
```


---
##  عملیات روی لیست پیوندی

### عملیات درج

تصور کنید که می‌خواهیم یک گره B (گره جدید) را بین گره A (گره چپ) و گره C (گره راست) درج کنیم.
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]



                            [Data|Next]

                                ^
                                |
                            B(New node)
```
در این صورت B باید به C به عنوان next اشاره کند:

`B(New node).next -−> C(Right node);`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]

                                                     ^
                                                     |
                         [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
اینک گره سمت راست (A) باید به گره جدید (B) اشاره کند:

`A(Left node).next -−> B(New node);`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(B)]                               [Data|Next]
            |
            |                                         ^
            |                                         |
            \-----------> [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
بدین ترتیب گره جدید در میان دو گره قبلی قرار می‌گیرد. لیست جدید به صورت زیر خواهد بود:
```
     A(Left node)                                    C(Right node)
          |                                                |
          v                                                v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]

                                   ^
                                   |
                               B(New node)
```
اگر بخواهیم گرهی را در ابتدای لیست اضافه کنیم نیز مراحل مشابهی را طی می‌کنیم، فقط در یک سمت بجای گره head را داریم.

 زمانی که می‌خواهیم گرهی را در انتهای لیست درج کنیم، گره جدید به یک مقدار null اشاره می‌کند.
</br>
</br>
### عملیات حذف
ابتدا گره هدف که می‌خواهیم حذف کنیم را با استفاده از الگوریتم‌های جستجو می‌یابیم.

فرض کنید اینبار میخواهیم گره B را از میان A و C حذف کنیم:
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]
```
گره چپ (A) باید به گره راست هدف (C) اشاره کند:

`A(Left node).next −> C(Target node.next);`
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(C)]          [Data|Next(C)]---------> [Data|Next]
             |                                            ^
             |                                            |
             \____________________________________________/
```
با این کار پیوندی که از گره راست (A) به گره هدف(B) وجود داشت از بین می‌رود. حالا اشاره‌گر گره هدف (B) را حذف میکنیم تا ارتباطش با گره راست (C) هم قطع شود:

`B(Target node).next −> NULL;`
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(C)]          [Data|Next(C)]           [Data|Next]
             |                                            ^
             |                                            |
             \____________________________________________/
```
 ما می‌توانیم گره حذف شده (B) را در حافظه نگه داریم ولی حالا که نیازی به آن نداریم می‌توانیم به سادگی آن را به طور کامل پاک کنیم و حافظه اشغال شده را آزاد کنیم:

`Delete(node B);`
```
     A(Left node)            C(Right node)
          |                         |
          v                         v
    [Data|Next(C)] ----------> [Data|Next]
```


---


##  انواع لیست‌های پیوندی
چند مدل لیست پیوندی داریم که اینجا می‌بینیم:
### لیست پیوندی یک‌طرفه (Singly Linked List)

```
Head
  |
  v
[10|Next] -> [20|Next] -> [30|Next] -> None
```
همانی که بالا هم توضیح دادیم، نوع عادی و اولیه لیست پیوندی حداقل به دو قسمت داده و اشاره‌گر نیاز دارد.

لیست پیوندی یک‌‌طرفه در پیاده‌سازی صف‌ها، پشته‌ها و برخی از الگوریتم‌ های مرتب‌سازی کاربرد دارد.

---

### لیست پیوندی دوطرفه (Doubly Linked List)

```
None <- [Prev|10|Next] <-> [Prev|20|Next] <-> [Prev|30|Next] -> None
```
گره های این مدل لیست پیوندی می‌توانند هم به عنصر بعدی‌شان اشاره کنند و هم به قبلی!

در واقع با استفاده از یک اشاره‌گر دیگر (Prev) می‌توانند به عضو قبلی هم اشاره کنند، پس میشود به عقب هم پیمایش کرد ولی برای ذخیره اشاره‌گر اضافی به حافظه بیشتری نیاز است.

این لیست انعطاف‌پذیری بیشتری دارد و
عملیات درج و حذف عناصر در وسط لیست به خاطر وجود اشاره‌گر به گره قبلی، سریع‌تر انجام می‌شود.بیشترین کاربردش هم در پیاده‌سازی گراف‌ها است.


---

### لیست پیوندی حلقوی (Circular Linked List)

```
     ___________________________
    /                           \
    |                           |
    v                           |
[10|Next] -> [20|Next] -> [30|Next]

```
این لیست پیوندی ساختار دایره‌ای دارد. در واقع، اشاره‌گر آخرین گره به گره اول اشاره می‌کند و یک ساختار دایره‌ای رو تشکیل می‌دهد؛ همچنین پیمایش مداومی هم داره که می‌شود از هر گره‌ای شروع کرد و به همان گره بازگشت. کاربرد آن نیز در پیاده‌سازی صف‌های حلقوی و مدیریت حافظه است.

این نوع لیست هم می‌تواند هم به صورت یک طرفه و هم دو طرفه باشد.



---


##  مزایا و معایب

### مزایای لیست های پیوندی
به عنوان مزیت، می‌توانیم به سه نکته برجسته درباره این نوع از لیست‌های پیوندی اشاره کنیم:

 <b> «آزادی سازی حافظه پویا (Dynamic Memory Allocation | DMA): </b>  به این معنا که اندازه لیست در زمان اجرای برنامه با حذف شدن یا اضافه شدن داده‌های لیست به‌ صورت پویا کم یا زیاد می‌شود.

 <b> «ورود و حذف داده» (Insertion And Deletion): </b>عملیات مربوط به ورود و حذف داده‌ها در لیست پیوندی به صورت بهینه‌ای انجام می‌پذیرد. این بهینه‌گی به خصوص در زمان کار با لیست‌های بزرگ خود را نشان می‌دهد.

 <b>«کارآمدی در فضای حافظه» (Space-Efficient):</b> لیست‌های پیوندی در استفاده از فضای ذخیره‌سازی بسیار کارآمد هستند. زیرا این لیست‌ها به‌جای اینکه فضای پیوسته و بزرگی از حافظه را اشغال کنند، برای هر عنصر فقط به ذخیره آدرس گره بعدی نیاز دارند.

 <b> سادگی در پیاده سازی: </b>پیاده‌سازی لیست‌های پیوندی در مقایسه با سایر ساختمان‌های داده پیچیده‌تر مانند درخت‌ها و گراف‌ها می‌تواند نسبتا ساده باشد.

<b>«انعطاف‌پذیری» (Flexibility): </b> لیست‌های پیوندی را می‌توان به سادگی اصلاح کرد یا از اول سازماندهی کرد. اجرای این عملیات نیازی به وجود بلاک‌های حافظه‌ای متوالی و بهم چسبیده ندارد.

### معایب لیست های پیوندی
 <b>کارایی ضعیف در دسترسی تصادفی</b>: برای دسترسی به هر مقداری در لیست‌های پیوندی باید از سمت سر لیست تا رسیدن به گره حاوی مقدار مورد نظر پیمایش کنیم. این نوع از دسترسی، لیست پیوندی را برای اجرای عملیات دسترسی تصادفی نسبت به آرایه‌ها بسیار ضعیف‌تر می‌کند.

 <b>افزایش سربار حافظه</b>: لیست‌های پیوندی نیاز به حافظه اضافی برای ذخیره آدرس گره بعدی یا نشانگر در هر گره دارند. این کار باعث می‌شود که در مقایسه با آرایه‌ های برنامه نویسی هزینه بیشتری را بر روی حافظه سیستم وارد کنند.

 <b>آسیب‌پذیر بودن در مقابل از دست رفتن داده‌ها</b>: در لیست‌های پیوندی،
اگر اشاره‌گر گره‌‌ای حذف یا خراب شود دیگر امکان پیمایش بر بروی لیست و دسترسی به گره‌های بعدی وجود ندارد. در نتیجه لیست‌های پیوندی در مقابل از دست‌دادن داده‌ها می‌توانند بسیار آسیب‌پذیر باشند.

 <b>نامناسب برای پردازش‌های موازی</b>: لیست‌های پیوندی برای پردازش‌های موازی مناسب نیستند. زیرا به‌روزرسانی مقادیر گره‌ها نیازمند دسترسی انحصاری به اشاره‌گر گره بعدی دارد و دسترسی انحصاری چیزی نیست که به‌سادگی در محیط‌های عملیاتی موازی بدست آید.

 <b>پیمایش در لیست‌های یک طرفه روبه‌عقب ممکن نیست</b>: لیست‌های پیوندی یک‌‌ ظرفه، از عملیات پیمایش لیست به سمت عقب پشتیبانی نمی‌کنند. در واقع گره‌ها اصلا نمی‌دانند که گره قبلی در کجای حافظه قرار دارد.

---
## مثال‌هایی از کاربرد لیست‌های پیوندی در زندگی واقعی

### تاریخچه مرورگر وب (Back/Forward Button)

این احتمالاً معروف‌ترین و قابل لمس‌ترین مثال است.
- **چگونه کار می‌کند:** وقتی شما در مرورگر خود از صفحهای به صفحه دیگر میروید، آدرس هر صفحه به عنوان یک "گره" در یک **لیست پیوندی دوطرفه** ذخیره می‌شود.
- **گره فعلی:** صفحهای که هم اکنون میبینید.
- **دکمه Back (عقب):** اشاره‌گر را به گره قبلی در لیست منتقل می‌کند.
- **دکمه Forward (جلو):** اشاره‌گر را به گره بعدی در لیست منتقل می‌کند.

### پخش کننده موسیقی (Playlist)

لیست پخش آهنگ‌های شما یک لیست پیوندی کلاسیک است.
- **چگونه کار می‌کند:** هر آهنگ یک گره است که حاوی داده‌های آهنگ و یک اشاره‌گر به آهنگ بعدی است.
- **قابلیت پخش متوالی:** پخش کننده به راحتی از یک آهنگ به آهنگ بعدی می‌رود.
- **حذف و اضافه کردن آهنگ:** فقط با تغییر اشاره‌گرهای گره‌های قبلی و بعدی انجام می‌شود.

### مدیریت حافظه در سیستم عامل

سیستم عامل از لیست‌های پیوندی برای پیگیری بلوک‌های حافظه استفاده می‌کند.
- **چگونه کار می‌کند:** هر گره نشان‌دهنده یک بخش از حافظه (آغاز، پایان، وضعیت) است.
- **تخصیص حافظه:** سیستم عامل در لیست به دنبال بلوک "آزاد" با اندازه مناسب می‌گردد.
- **آزادسازی حافظه:** بلوک به لیست بلوک‌های آزاد اضافه شده و با بلوک‌های مجاور ادغام می‌شود.

### کنترل حرکت قطار یا مترو

یک خط مترو یا قطار را می‌توان با یک لیست پیوندی مدل کرد.
- **چگونه کار می‌کند:** هر ایستگاه یک گره است و خط ریل، پیوند بین گره‌ها را نشان می‌دهد.
- **حرکت قطار:** قطار از یک ایستگاه به ایستگاه بعدی حرکت می‌کند.

### سیستم Undo / Redo در نرم‌افزارها

در نرم‌افزارهایی مانند Word و Photoshop:
- **چگونه کار می‌کند:** هر عمل کاربر به عنوان یک گره در **لیست پیوندی دوطرفه** ذخیره می‌شود.
- **دکمه Undo:** اشاره‌گر را به گره قبلی منتقل می‌کند.
- **دکمه Redo:** اشاره‌گر را به گره بعدی برمی‌گرداند.

### صف‌های پیاده‌سازی شده با لیست پیوندی

صف‌ها را می‌توان به طور کارآمدی با لیست پیوندی پیاده‌سازی کرد:
- **چاپ اسناد:** اسناد در صف قرار می‌گیرند (FIFO)
- **پشتیبانی مشتری:** تماس‌های در انتظار در صف قرار می‌گیرند

### تصادم‌ها در Hash Tables

در ساختار داده "جدول درهم‌سازی":
- **حل تصادم:** وقتی دو کلید به یک مکان اشاره می‌کنند، مقادیر در یک لیست پیوندی ذخیره می‌شوند.

### نکته:
برخلاف تصور لیست های پایتون از لیست پیوندی استفاده نمی‌کنند و در واقع آرایه‌های پویا یا همان `Dynamic Arrays` هستند.
</br>
</br>

---
##  تفاوت های لیست پیوندی با آرایه
</br>
برای اینکه بدانیم چه وقت و چرا باید بجای آرایه از لیست‌ پیوندی استفاده کنیم، باید تفاوت ها و مزیت های لیست پیوندی با آرایه را بدانیم.
</br>

### ساختار، اندازه و میزان حافظه اشغالی
در حالی که آرایه ها به صورت پشت سر هم در حافظه ذخیره میشوند، لیست های پیوندی نیازی ندارند که پی در پی باشند و هرکدوم میتونند هرجایی باشند.
```
        آرایه:
        [ 10 ][ 20 ][ 30 ]


        لیست پیوندی:
        [ 10 ] -----------------------> [ 20 ]
                                          |
                    [ 30 ] <--------------/
                    |
                    \---------> NULL
```
برای اینکه هر node در لیست بتواند node بعدی را هر کجا که باشد پیدا کند، نیاز به آدرس node بعدی دارد:
```
    HEAD
        |
        v
    +------+-----+      +------+-----+      +------+-----+
    |  10  |  *------>  |  20  |  *------>  |  30  | NULL|
    +------+-----+      +------+-----+      +------+-----+
        (گره اول)             (گره دوم)             (گره آخر)
```
در نتیجه لیست پیوندی بخاطر اینکه یک آدرس یا pointer هم باید ذخیره کند به حافظه بیشتری هم نسبت به آرایه نیاز دارد.

آرایه ها اندازه ثابتی دارند و این اندازه باید در هنگام تعریف آرایه مشخص بشود. شاید فکر کنید بعضی زبان های برنامه نویسی مثل python و javascript میتوانند اندازه متغیری داشته باشند، ولی در واقع آرایه در آنها هم اندازه ثابتی دارد! وقتی شما یک داده دیگه را به آرایه اضافه می کنید، آرایه قبلی پاک می‌شود و همه داده‌ها به یک آرایه جدید (و بزرگ‌تر) اضافه میشوند.
در حالی که یک لیست پیوندی میتواند اندازه کاملا متغیری داشته باشه و تغییر کند.
### سرعت پیدا کردن اطلاعات

فرض کنید ما میخواهیم آیتم 100 ام از یک آرایه را بخوانیم، کار بسیار راحتی خواهد بود کافی است از آدرس آیتم اول، 'گره' و نه خانه به جلو برویم. پس عملا ما با یک عملیات آیتم صدم را پیدا میکنیم، بنابراین پیچیدگی زمانی آن، O(1) خواهد بود.
اما درباره لیست پیوندی، قضیه متفاوت خواهد بود، برای پیدا کردن آیتم صدم در لیست پیوندی ابتدا باید آیتم یک را پیدا کنیم سپس آدرس آیتم دوم را در آنجا پیدا کنیم، بعد آیتم سوم و چهارم و… همین روند را ادامه بدهیم تا بالاخره به آیتم صدم برسیم. به عبارتی باید خانه ها را یکی یکی به جلو بیاییم پس پیچیدگی زمانی پیدا کردن آیتم در لیست پیوندی به صورت O(n) خواهد بود.
</br>
</br>
### سرعت اضافه یا حذف کردن دیتا

به نظر می‌رسد اضافه کردن دیتا به آرایه کار راحتی است، کافیست بعد از آخرین آیتم، یک آیتم جدید قرار دهیم. اما مسئله، زمانی پیچیده می‌شود که بخواهیم به اول یا اواسط یک آرایه آیتم جدید اضافه کنیم، در این صورت لازم داریم که تمام آیتم های بعدی را به یک خانه جلوتر منتقل کنیم. برای مثال اگر ما یک آرایه داشته باشیم که در حال حاضر ده عضو داشته باشد و بخواهیم به اول آن یک آیتم جدید اضافه کنیم باید آیتم یک را ببریم بجای آیتم دو و آیتم دو بجای آیتم سه ببریم و همین روند را ادامه دهیم تا همه آیتم ها یک خانه جابجا شوند و بتوانیم آیتم جدید را در خانه اول بگذاریم. اضافه کردن به میانه آرایه هم فرایند مشابهی دارد.

همین روند برای حذف کردن دیتا هم وجود دارد. باید تمام آیتم های بعد از آیتم حذف شده، یک خانه به عقب برگردند. برای حذف و اضافه کردن در آرایه، ممکن است نیاز پیدا کنیم تا همه آیتم ها را جابجا کنیم، پس میتوانیم بگوییم که پیچیدگی زمانی این فرایند به صورت O(n) خواهد بود.

اما درباره لیست پیوندی چطور؟ اضافه کردن در لیست پیوندی بسیار ساده است، آیتم جدید را در هر جایی از حافظه که بخواهیم قرار میدهیم و آدرس آن را در آیتم قبلی قرار میدهیم. فرض کنیم که یه لیست پیوندی با 10 آیتم داریم و میخواهیم آیتم جدیدی بین آیتم 3 و 4 اضافه کنیم. کافیست آیتم جدید را در جایی از حافظه قرار دهیم و آدرس آن را به آیتم 3 بدهیم و آدرس آیتم 4 را به آیتم جدید بدهیم. بدون اینکه نیاز به جابجایی دیتا های قبلی وجود داشته باشد.

حذف کردن از لیست پیوندی نیز کار راحتی خواهد بود، کافییست آیتم مورد نظر را از حافظه حذف کنیم و آدرس آیتم بعدی را به آیتم قبلی بدهیم. اضافه و حذف کردن در لیست پیوندی با یک عملیات انجام خواهد شد پس پیچیدگی زمانی آن به صورت O(1) خواهد بود.

</br>
</br>
</br>

---

<table>
<tr>
<th>ویژگی</th>
<th>آرایه</th>
<th>لیست پیوندی</th>
</tr>
</tr>
<tr>
<td>حافظه</td>
<td>کمتر</td>
<td>بیشتر (برای اشاره‌گرها)</td>
</tr>
<tr>
<td>اندازه</td>
<td>ثابت</td>
<td>پویا</td>
</tr>
<tr>
<td>دسترسی به عناصر</td>
<td>خیلی سریع O(1)</td>
<td>زمان برO(n)</td>
<tr>
<td>درج/حذف</td>
<td>زمان‌بر O(n)</td>
<td>خیلی سریع O(1)</td>
</tr>
</table>


### نتیجه

اینکه سراغ کدام یک برویم بستگی به نیاز ما دارد. اگر قرار است که مجموعه ای داشته باشیم که مدام به آن اضافه یا از آن حذف کنیم، بهتر است از لیست پیوندی استفاده کنیم. برای مثال اگر بخواهیم یک نرم افزار todo list بنویسیم که کار هایمان را در آن قرار دهیم بهتر است از لیست پیوندی استفاده کنیم چون مدام نیاز داریم میان کارهای قبلی، کار جدیدی اضافه کنیم و کار هایی که انجام میدهیم را از لیست حذف کنیم.

اما اگر مجموعه داده های ما تغییرات زیادی ندارد و ما نیاز داریم که مدام از میانه آن آیتم های مان را بخوانیم بهتر است از آرایه کمک بگیریم، برای مثال اگر بخواهیم یک نرم افزار دیکشنری بنویسیم بهتر است از آرایه برای نگهداری لغات استفاده کنیم به دلیل اینکه لغات دیکشنری معمولا کم و زیاد نمیشود اما در عوض همیشه نیاز داریم که کلمه مورد نظرمان را بین کلمات پیدا کنیم.


---
